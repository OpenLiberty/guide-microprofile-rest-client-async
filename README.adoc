// Copyright (c) 2017, 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: microprofile-rest-client-async
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2019-07-05
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Rest Client to invoke RESTful microservices over HTTP asynchronously.
:page-seo-title: Consuming REST services asynchronously
:page-seo-description: A tutorial on how to consume REST services asynchronously with MicroProfile Rest Client.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Java EE']
:page-permalink: /guides/{projectid}
:page-related-guides: ['microprofile-rest-client']
:common-includes: ../guides-common/
:imagesdir: /img/guide
:source-highlighter: prettify
:mac: Mac
:win: Windows
:linux: Linux
= Consuming RESTful services asynchronously

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use MicroProfile Rest Client to invoke RESTful microservices over HTTP asynchronously.

== What you'll learn

You will learn how to build a MicroProfile Rest Client to access remote RESTful services using asynchronous method calls. You'll update a template interface that maps to the remote service that you want to call. You'll change it to use a `CompletionStage` return type making the method asynchronous. A `CompletionStage` is an interface that will allow you to use the result of your remote service call at some point in the future.

=== What is asynchronous programming?

Asynchronous programming can be thought of as a restaurant. After being seated, a waiter will take your order. At this point, you will have to wait a few minutes for your food to be prepared. While your food is being prepared your waiter may take more orders or serve other tables. Once your food is ready, your waiter will be notified to bring out your food. However, in a synchronous model, the waiter would have to wait for your food to be prepared before dealing with any other customers. This method blocks other customers from placing orders or receiving their food.

Asynchronous methods allow you to perform a lengthy operation, such as input/output (IO) asynchronously. This means that the IO occurs in the background and the caller is notified via a callback to continue with their computation once it’s complete. The benefit is that this frees up the original thread to handle other work rather than waiting on IO to complete. Going back to the restaurant analogy, food is prepared asynchronously in the kitchen and your waiter is freed up to attend to other tables. Since they’re free, the waiter can take more orders from other tables, or serve food to other tables.

In the context of MicroProfile REST client, making HTTP requests can be a time consuming process. The network may be slow, or maybe the upstream service is overwhelmed and can't respond quickly. These lengthy operations can block the execution of your thread when it's in use and prevent other work from being completed.

The application you will be working with is a job manager that maintains an inventory of available systems.
It consists of four microservices `gateway`, `job`, `system`, and `inventory`.
The `job` microservice allows you to dispatch jobs that will be run by the `system` microservice.
The job is a sleep operation used to represent a slow task that lasts for a duration of 5 to 10 seconds. When it completes, the `system` microservice
reports the sleep time as the result of this job. In addition to running jobs, the `system` microservice also registers
itself on startup with the `inventory` microservice that keeps track of all instances of the `system` microservice. Finally,
the `gateway` microservice is a https://microservices.io/patterns/apigateway.html#variation-backends-for-frontends[backend for frontend^].
It communicates with the backend `job` and `inventory` microservices on the caller's behalf.

image::reactive-inventory-system.png[Reactive Inventory System,width=100%]

The microservice that you will modify with is the `gateway` service.
It acts as a gateway to communicate with the backend microservices.
Whenever a request is made to the `gateway` service to retrieve the jobs
the `gateway` service communicates with the `job`
service on that host to get the completed jobs.

The implementations of the application and its services are provided for you in the `start/src` directory.
The application also uses the Apache Kafka and ZooKeeper services to distribute the job results and system status.

If you want to learn more about MicroProfile Rest Client, you can read the https://openliberty.io/guides/microprofile-rest-client.html[Consuming RESTful services with template interfaces^] guide.


// =================================================================================================
// Getting started
// =================================================================================================

[role='command']
include::{common-includes}/gitclone.adoc[]

== Changing the template interface to use asynchronous methods

Navigate to the `start` directory to begin.

First, you will make the job client interface methods asynchronous.

[role="code_command hotspot", subs="quotes"]
----
#Replace the `JobClient` interface.#
`gateway/src/main/java/io/openliberty/guides/gateway/client/JobClient.java`
----
JobClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/gateway/src/main/java/io/openliberty/guides/gateway/client/JobClient.java[]
----

The changes involve changing the return types of the [hotspot=getJobs file=0]`getJobs`, [hotspot=getJob file=0]`getJob`, and [hotspot=createJob file=0]`createJob` methods to return `CompletionStage<T>` types. These changes make the methods asynchronous. Since the methods now have a return type of `CompletionStage<T>`, you won’t be able to directly manipulate the inner type. As you will see in the next section, you will be able to indirectly use the inner object by chaining callbacks.

== Responding asynchronously to an HTTP request

JAX-RS resources can also have asynchronous methods. So instead of returning a `JobsListModel` type, you may return a `CompletionStage<JobsListModel>` type. Completion stages can be chained together using the [hotspot=thenApplyAsync file=0]`thenApplyAsync()` method.

[role="code_command hotspot", subs="quotes"]
----
#Replace the `JobResource` class.#
`gateway/src/main/java/io/openliberty/guides/gateway/JobResource.java`
----
JobResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/gateway/src/main/java/io/openliberty/guides/gateway/JobResource.java[]
----

Similar to the synchronous approach, if we successfully get the completed jobs from the `job` microservice, then the resource will respond with an HTTP status of 200 and the body will contain a list of jobs. Finally, return the `CompletionStage<JobsListModel>` you built up using the [hotspot=thenApplyAsync file=0]`thenApplyAsync()`.

The `CompletionStage` interface represents a unit of computation. Once that computation completes, it can either be finished or chained with more completion stages using [hotspot=thenApplyAsync file=0]`thenApplyAsync()` to perform more computations. Exceptions can be handled in a callback provided to the [hotspot=exceptionally file=0]`exceptionally()` method, which functionally behaves similar to a catch block. When you return a `CompletionStage` in the resource, it doesn’t necessarily mean that the computation has completed and the response has been built. JAX-RS will respond to the caller once the `CompletionStage` has completed.

// =================================================================================================
// Building the application
// =================================================================================================

== Building and running the application

The `gateway`, `job`, `system`, and `inventory` microservices will be built in a Docker container. You can learn more about https://openliberty.io/guides/containerize.html[Containerizing microservices^].

Install Docker by following the instructions on the https://docs.docker.com/engine/installation[official page^]. Start your Docker environment.

To build the application, run the Maven `package` goal from the command line in the `start` directory.

[role='command']
```
mvn clean package
```

Run the following commands to build and containerize the application:

[role='command']
```
docker build -t system:1.0-SNAPSHOT system/.
docker build -t inventory:1.0-SNAPSHOT inventory/.
docker build -t job:1.0-SNAPSHOT job/.
docker build -t gateway:1.0-SNAPSHOT gateway/.
```

Next, use the provided script to start the application in docker containers. The script creates a network for the containers to communicate with each other. It also spawns containers for kafka, zookeeper, and all of the microservices in the project. The services will take some time to become available.

****
[system]#*{linux} | {mac}*#

[role='command']
```
./scripts/start-app
```

[system]#*{win}*#

[role='command']
```
.\scripts\start-app.bat
```
****

You can access the application by making requests to the `gateway` job endpoints.

[options="header"]
|===
|Description |Endpoint |Sample Output
|Get completed jobs |GET http://localhost:8080/api/jobs[http://localhost:8080/api/jobs^] |`{"count":0,"results":[]}`
|Create a job |POST http://localhost:8080/api/jobs[http://localhost:8080/api/jobs^] |`{"jobId":"661891cb-ad36-4ef4-9bb3-641f973f2964"}`
|Get a specific job |GET http://localhost:8080/api/jobs/{jobId} |`{"jobId":"661891cb-ad36-4ef4-9bb3-641f973f2964","result":5}`
|===

You can use `curl -X POST \http://localhost:8080/api/jobs` command if available on the system to create a job. The Postman application can also be used. The request will take some time for the job results to return.

The completed jobs JSON output has `averageResult` that is the average sleep time of all the jobs, a count for the number of jobs and the list of the jobs. Each job JSON output has a job ID and a sleep time as the result for this job.

Switching to an asynchronous programming model has freed up the thread handling your request to `/api/jobs`. While MicroProfile REST Client makes a request, the thread can handle other work.

// =================================================================================================
// Testing
// =================================================================================================

== Testing the gateway application

A few tests are included for you to test the basic functionality of the `gateway` microservice. If a test failure occurs, then you may have introduced a bug into the code.

[role="code_command hotspot", subs="quotes"]
----
#Create the `JobEndpointTest` class.#
`gateway/src/test/java/it/io/openliberty/guides/gateway/JobEndpointTest.java`
----

See the following descriptions of the test cases:

* [hotspot=testCreateJob file=0]`testCreateJob()` verifies that the gateway service communicates with a backend service to create a job.

* [hotspot=testGetJobs file=0]`testGetJobs()` verifies that the gateway service communicates with an upstream service to get all jobs and transforms them appropriately to a `JobListModel`.

JobEndpointTest.java
[source, Java, linenums, role='code_column hide_tags=copyright,javadoc']
----
include::finish/gateway/src/test/java/it/io/openliberty/guides/gateway/JobEndpointTest.java[]
----

// =================================================================================================
// Running the tests
// =================================================================================================

=== Running the tests

Navigate to the `gateway` directory, then verify that the tests pass using the Maven `verify` goal:

[role='command']
```
mvn verify
```

When the tests succeed, you will see output similar to the following.

[source, role='no_copy']
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.gateway.InventoryEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.88 s - in it.io.openliberty.guides.gateway.InventoryEndpointTest
Running it.io.openliberty.guides.gateway.JobEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.455 s - in it.io.openliberty.guides.gateway.JobEndpointTest

Results:

Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
----

== Teardown

Navigate back to the `start` directory.

Finally, use the script to stop the application.

****
[system]#*{linux} | {mac}*#

[role='command']
```
./scripts/stop-app
```

[system]#*{win}*#

[role='command']
```
.\scripts\stop-app.bat
```
****

== Great work! You're done!

You have just completed modifying an application to make asynchronous HTTP requests using Open Liberty.

include::{common-includes}/attribution.adoc[subs="attributes"]
